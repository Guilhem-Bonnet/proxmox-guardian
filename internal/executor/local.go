package executorpackage executor











































































































}	return fmt.Sprintf("Local: %s", truncateCmd(l.Command))func (l *LocalExecutor) String() string {// String returns a human-readable description}	return !result.Success, nil	}		return result.Success, nil	if expectSuccess {		expectSuccess := l.BaseAction.Healthcheck.Expect == "success"		result, _ := checkExec.Execute(ctx)		checkExec.Timeout = 10 * time.Second	checkExec := NewLocalExecutor(l.BaseAction.Healthcheck.Command)		}		return true, nil	if l.BaseAction.Healthcheck == nil {func (l *LocalExecutor) Healthcheck(ctx context.Context) (bool, error) {// Healthcheck verifies the action completed}	return recoveryExec.Execute(ctx)		recoveryExec.Timeout = l.Timeout	recoveryExec := NewLocalExecutor(l.Recovery)		}		}, nil			Output:  "no recovery command defined",			Success: true,		return &ActionResult{	if l.Recovery == "" {func (l *LocalExecutor) Recover(ctx context.Context) (*ActionResult, error) {// Recover runs the recovery command}	}, nil		Duration: time.Since(start),		Output:   stdout.String(),		Success:  true,	return &ActionResult{		}		}, err			Duration: time.Since(start),			Error:    fmt.Sprintf("%v: %s", err, stderr.String()),			Output:   stdout.String(),			Success:  false,		return &ActionResult{	if err != nil {		}		}, ctx.Err()			Duration: time.Since(start),			Error:    "command timed out",			Output:   stdout.String(),			Success:  false,		return &ActionResult{	if ctx.Err() == context.DeadlineExceeded {		err := cmd.Run()		cmd.Stderr = &stderr	cmd.Stdout = &stdout	var stdout, stderr bytes.Buffer		cmd := exec.CommandContext(ctx, l.Shell, "-c", l.Command)		defer cancel()	ctx, cancel := context.WithTimeout(ctx, l.Timeout)	// Create command with context for timeout		start := time.Now()func (l *LocalExecutor) Execute(ctx context.Context) (*ActionResult, error) {// Execute runs the local command}	}		Shell: "/bin/sh",		},			Timeout: 60 * time.Second,			Command: command,			Type:    "local",		BaseAction: BaseAction{	return &LocalExecutor{func NewLocalExecutor(command string) *LocalExecutor {// NewLocalExecutor creates a new local executor}	Shell string	BaseActiontype LocalExecutor struct {// LocalExecutor executes commands locally)	"time"	"os/exec"	"fmt"	"context"	"bytes"import (